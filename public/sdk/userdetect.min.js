/**
 * UserDetect SDK v1.0.0
 * Browser-based user location detection.
 * Usage: UserDetect.init('api_key', callback, options);
 */
var UserDetect = (function() {
    'use strict';

    var _apiKey = null;
    var _options = {};
    var _callback = null;
    var _lastDetection = null;
    var _fingerprint = null;
    var _initialized = false;

    var DEFAULTS = {
        apiEndpoint: '',
        timeout: 10000,
        debug: false,
        autoDetect: true,
        returnAlternatives: false
    };

    // ---- Fingerprint ----

    function sha256(str) {
        var buffer = new TextEncoder().encode(str);
        return crypto.subtle.digest('SHA-256', buffer).then(function(hashBuffer) {
            var hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(function(b) { return b.toString(16).padStart(2, '0'); }).join('');
        });
    }

    function getCanvasFingerprint() {
        try {
            var canvas = document.createElement('canvas');
            canvas.width = 200; canvas.height = 50;
            var ctx = canvas.getContext('2d');
            ctx.textBaseline = 'top';
            ctx.font = '14px Arial';
            ctx.fillStyle = '#f60';
            ctx.fillRect(125, 1, 62, 20);
            ctx.fillStyle = '#069';
            ctx.fillText('UserDetect,fp!', 2, 15);
            ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
            ctx.fillText('UserDetect,fp!', 4, 17);
            ctx.beginPath();
            ctx.arc(50, 25, 10, 0, Math.PI * 2);
            ctx.fillStyle = '#f0f';
            ctx.fill();
            return canvas.toDataURL();
        } catch (e) { return ''; }
    }

    function getWebGLFingerprint() {
        try {
            var canvas = document.createElement('canvas');
            var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (!gl) return '';
            var debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
            var vendor = debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : '';
            var renderer = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : '';
            return vendor + '~' + renderer;
        } catch (e) { return ''; }
    }

    function getAudioFingerprint() {
        try {
            var AC = window.AudioContext || window.webkitAudioContext;
            if (!AC) return '';
            var context = new AC();
            var analyser = context.createAnalyser();
            var data = new Float32Array(analyser.frequencyBinCount);
            analyser.getFloatFrequencyData(data);
            context.close();
            return Array.from(data.slice(0, 30)).join(',');
        } catch (e) { return ''; }
    }

    function detectFonts() {
        var baseFonts = ['monospace', 'sans-serif', 'serif'];
        var testFonts = ['Arial','Courier New','Georgia','Times New Roman','Trebuchet MS','Verdana','Comic Sans MS','Impact','Lucida Console','Tahoma','Palatino','Garamond','Calibri'];
        var testString = 'mmmmmmmmlli';
        var span = document.createElement('span');
        span.style.fontSize = '72px';
        span.style.position = 'absolute';
        span.style.left = '-9999px';
        span.textContent = testString;
        document.body.appendChild(span);

        var baseWidths = {};
        baseFonts.forEach(function(f) { span.style.fontFamily = f; baseWidths[f] = span.offsetWidth; });

        var detected = [];
        testFonts.forEach(function(font) {
            var found = baseFonts.some(function(base) {
                span.style.fontFamily = "'" + font + "', " + base;
                return span.offsetWidth !== baseWidths[base];
            });
            if (found) detected.push(font);
        });

        document.body.removeChild(span);
        return detected.join(',');
    }

    function generateFingerprint() {
        try {
            var cached = sessionStorage.getItem('__ud_fp');
            if (cached) return Promise.resolve(cached);
        } catch (e) {}

        var components = [
            getCanvasFingerprint(),
            getWebGLFingerprint(),
            getAudioFingerprint(),
            detectFonts(),
            screen.width + 'x' + screen.height + 'x' + screen.colorDepth + 'x' + (window.devicePixelRatio || 1),
            (function() { try { return Intl.DateTimeFormat().resolvedOptions().timeZone; } catch(e) { return ''; } })(),
            navigator.language,
            navigator.platform,
            navigator.hardwareConcurrency || 0,
            navigator.deviceMemory || 0,
            navigator.maxTouchPoints || 0,
            new Date().getTimezoneOffset()
        ];

        var raw = components.join('|||');
        return sha256(raw).then(function(hash) {
            try { sessionStorage.setItem('__ud_fp', hash); } catch(e) {}
            return hash;
        });
    }

    // ---- Signals ----

    function collectSignals(fingerprint) {
        return {
            fingerprint: fingerprint,
            timezone: (function() { try { return Intl.DateTimeFormat().resolvedOptions().timeZone; } catch(e) { return null; } })(),
            timezone_offset: new Date().getTimezoneOffset(),
            language: navigator.language || null,
            languages: navigator.languages ? Array.from(navigator.languages) : [],
            user_agent: navigator.userAgent,
            screen: {
                width: screen.width,
                height: screen.height,
                color_depth: screen.colorDepth,
                pixel_ratio: window.devicePixelRatio || 1
            },
            platform: navigator.platform || null,
            hardware_concurrency: navigator.hardwareConcurrency || null,
            device_memory: navigator.deviceMemory || null
        };
    }

    // ---- API Client ----

    function makeRequest(url, headers, body, timeout) {
        var controller = new AbortController();
        var timeoutId = setTimeout(function() { controller.abort(); }, timeout);

        return fetch(url, {
            method: 'POST',
            headers: headers,
            body: body,
            signal: controller.signal
        }).then(function(response) {
            clearTimeout(timeoutId);
            if (!response.ok) {
                return response.json().catch(function() { return {}; }).then(function(data) {
                    return { success: false, error: data.error || { code: 'HTTP_ERROR', message: 'HTTP ' + response.status } };
                });
            }
            return response.json();
        }).catch(function(err) {
            clearTimeout(timeoutId);
            throw err;
        });
    }

    function sendDetection(apiKey, signals, options) {
        var endpoint = (options.apiEndpoint || '').replace(/\/$/, '') + '/v1/detect';
        var timeout = options.timeout || 10000;
        var body = JSON.stringify({ signals: signals, options: { return_alternatives: options.returnAlternatives || false, include_debug_info: options.debug || false } });
        var headers = { 'Content-Type': 'application/json', 'X-API-Key': apiKey };

        return makeRequest(endpoint, headers, body, timeout).catch(function() {
            return new Promise(function(resolve) { setTimeout(resolve, 1000); }).then(function() {
                return makeRequest(endpoint, headers, body, timeout);
            });
        }).catch(function(err) {
            return { success: false, error: { code: 'NETWORK_ERROR', message: err.message || 'Failed to connect.' } };
        });
    }

    // ---- Endpoint Detection ----

    function detectApiEndpoint() {
        try {
            var scripts = document.getElementsByTagName('script');
            for (var i = scripts.length - 1; i >= 0; i--) {
                var src = scripts[i].src || '';
                if (src.indexOf('userdetect') !== -1) {
                    var url = new URL(src);
                    return url.origin + '/api';
                }
            }
        } catch (e) {}
        return window.location.origin + '/api';
    }

    // ---- Public API ----

    function init(apiKey, callback, options) {
        if (!apiKey) { console.error('[UserDetect] API key is required.'); return; }
        if (typeof callback !== 'function') { console.error('[UserDetect] Callback function is required.'); return; }

        _apiKey = apiKey;
        _callback = callback;
        _options = {};
        for (var k in DEFAULTS) _options[k] = DEFAULTS[k];
        if (options) { for (var k in options) _options[k] = options[k]; }
        _initialized = true;

        if (!_options.apiEndpoint) _options.apiEndpoint = detectApiEndpoint();
        if (_options.debug) console.log('[UserDetect] Initialized', _options);
        if (_options.autoDetect) detect().catch(function(e) { if (_options.debug) console.error('[UserDetect]', e); });
    }

    function detect() {
        if (!_initialized) return Promise.reject(new Error('SDK not initialized'));
        if (_options.debug) console.log('[UserDetect] Starting detection...');

        return generateFingerprint().then(function(fp) {
            _fingerprint = fp;
            if (_options.debug) console.log('[UserDetect] Fingerprint:', fp);
            var signals = collectSignals(fp);
            if (_options.debug) console.log('[UserDetect] Signals:', signals);
            return sendDetection(_apiKey, signals, _options);
        }).then(function(result) {
            _lastDetection = result;
            if (_options.debug) console.log('[UserDetect] Result:', result);
            if (_callback) _callback(result);
            return result;
        });
    }

    function getUserId() { return _fingerprint; }
    function getLastDetection() { return _lastDetection; }

    return {
        init: init,
        detect: detect,
        getUserId: getUserId,
        getLastDetection: getLastDetection
    };
})();
